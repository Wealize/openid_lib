{"version":3,"file":"vp-resolver.js","sourceRoot":"","sources":["../../../../src/core/presentations/vp-resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import jsonpath from 'jsonpath';\nimport fetch from 'node-fetch';\nimport {JwtPayload} from 'jsonwebtoken';\nimport {Resolver} from 'did-resolver';\nimport {importJWK, jwtVerify} from 'jose';\nimport {ajv} from './validator.js';\nimport {\n  DIFPresentationDefinition,\n  JwtFormat,\n  LdFormat,\n  PresentationInputDescriptor,\n  DIFPresentationSubmission,\n  DescriptorMap,\n  W3CVerifiablePresentation,\n} from '@/interfaces';\nimport {\n  W3CDataModel,\n  W3CVerifiableCredentialFormats,\n  W3CVerifiablePresentationFormats,\n} from '../../common/formats/index.js';\nimport {\n  JwtVpPayload,\n  JwtVcPayload,\n  W3CVcSchemaDefinition,\n  W3CVerifiableCredential,\n  W3CVerifiableCredentialV1,\n  W3CVerifiableCredentialV2,\n} from '../../common/interfaces/index.js';\nimport {\n  CONTEXT_VC_DATA_MODEL_1,\n  CONTEXT_VC_DATA_MODEL_2,\n  JWA_ALGS,\n  W3C_VP_TYPE,\n} from '../../common/constants/index.js';\nimport {\n  decodeToken,\n  didFromDidUrl,\n  getAssertionMethodJWKKeys,\n  getAuthentificationJWKKeys,\n  obtainDid,\n} from '../../common/utils/index.js';\nimport {\n  InternalNonceError,\n  InvalidRequest,\n} from '../../common/classes/error/index.js';\nimport {\n  CredentialAdditionalVerification,\n  NonceAndStateVerification,\n  VpExtractedData,\n} from './types.js';\nimport {SchemaObject} from 'ajv';\n\n/**\n * Component specialized in the verification of verifiable\n * submissions, for which it requires the original definition\n * and the submission delivered together with the VP.\n */\nexport class VpResolver {\n  private jwtCache: Record<\n    string,\n    {\n      type: 'vp' | 'vc';\n      data: JwtVcPayload | JwtVpPayload;\n      alg: JWA_ALGS;\n    }\n  >;\n  private vpHolder: string | undefined;\n  /**\n   * Main constructor of this class\n   * @param didResolver The DID Resolver to employ\n   * @param audience The expected audience in the tokens that will be processed\n   * @param externalValidation Callback that will be used to request external\n   * verification of any detected VC. This verification should focus on\n   * validating issues related to the trust framework and the use case.\n   * @param nonceAndStateValidation Callback the nonces specified in any JWT VP\n   * @param vcSignatureVerification Flag indicating whether the signatures of the VCs\n   * included in the VP should be verified. To that regard, the DID Resolver provided must\n   * be able to generate the needed DID Documents\n   */\n  constructor(\n    private didResolver: Resolver,\n    private audience: string,\n    private externalValidation: CredentialAdditionalVerification,\n    private nonceAndStateValidation: NonceAndStateVerification,\n    private vcSignatureVerification: boolean = false,\n  ) {\n    this.jwtCache = {};\n  }\n\n  /**\n   * Verify a Verifiable Presentation\n   * @param vp Any data structure in which the VP is located\n   * @param definition The definition of the presentation to be\n   * used to verify the PV\n   * @param submission The presentation submission submitted with the VP\n   * @returns Data extracted from the credentials contained\n   * in the VP as indicated in the definition provided.\n   */\n  async verifyPresentation(\n    vp: any,\n    definition: DIFPresentationDefinition,\n    submission: DIFPresentationSubmission,\n  ): Promise<VpExtractedData> {\n    try {\n      if (definition.id !== submission.definition_id) {\n        throw new InvalidRequest('The submission definition ID is incorrect');\n      }\n      if (\n        submission.descriptor_map.length !== definition.input_descriptors.length\n      ) {\n        throw new InvalidRequest(\n          'The descriptor map length does not coincide with the input descriptors one',\n        );\n      }\n      const idsAlreadyUsed = new Set<string>();\n      const descriptorClaimsMap = {} as Record<string, any>;\n      for (const descriptor of submission.descriptor_map) {\n        if (idsAlreadyUsed.has(descriptor.id)) {\n          throw new InvalidRequest(\"Can't be two descriptors with the same ID\");\n        }\n        const inputDescriptor = this.findDefinitionInputDescriptor(\n          definition,\n          descriptor.id,\n        );\n        const rootFormats = definition.format;\n        const format = inputDescriptor.format ?? rootFormats;\n        const vc = await this.extractCredentialFromVp(\n          vp,\n          descriptor,\n          rootFormats,\n          format,\n        );\n        const claimData = await this.resolveInputDescriptor(\n          inputDescriptor,\n          vc,\n        );\n        descriptorClaimsMap[inputDescriptor.id] = claimData;\n        idsAlreadyUsed.add(inputDescriptor.id);\n      }\n      this.jwtCache = {};\n      const result = {\n        claimsData: descriptorClaimsMap,\n        holderDid: this.vpHolder!,\n      };\n      this.vpHolder = undefined;\n      return result;\n    } catch (error: any) {\n      this.jwtCache = {};\n      this.vpHolder = undefined;\n      throw error;\n    }\n  }\n\n  private async deserializeJwtVc(\n    data: any,\n    validAlgs: JWA_ALGS[],\n    descriptorId: string,\n  ): Promise<{\n    data: JwtVcPayload;\n    jwa: JWA_ALGS;\n  }> {\n    if (typeof data !== 'string') {\n      throw new InvalidRequest('JWT Token must be in string format');\n    }\n    const cacheData = this.jwtCache[data];\n    if (cacheData && cacheData.type === 'vc') {\n      return {data: cacheData.data as JwtVcPayload, jwa: cacheData.alg};\n    }\n    const {header, payload} = decodeToken(data);\n    if (!header.kid) {\n      throw new InvalidRequest(\n        `Descriptor \"${descriptorId}\" JWT VC must contains a 'kid' parameter`,\n      );\n    }\n    if (!validAlgs.includes(header.alg as JWA_ALGS)) {\n      throw new InvalidRequest(\n        `Descriptor \"${descriptorId}\" JWT VC unssuported JWA: ${header.alg}`,\n      );\n    }\n    if (!('vc' in (payload as JwtPayload))) {\n      throw new InvalidRequest(`Descriptor ${descriptorId} is not a JWT VC`);\n    }\n    const vc = (payload as JwtVcPayload).vc as W3CVerifiableCredential;\n    const dataModelVersion = this.checkVcDataModel(vc);\n    this.verifyVcDates(vc, dataModelVersion, descriptorId);\n    if (!vc.credentialSubject.id) {\n      throw new InvalidRequest('Credential Subject not defined');\n    }\n    const vcSubject = vc.credentialSubject.id;\n    const vcSubjectDid = didFromDidUrl(vcSubject);\n    if (vcSubjectDid) {\n      if (!this.vpHolder) {\n        throw new InvalidRequest('A VC has been detected prior to any VP');\n      }\n      if (this.vpHolder !== vcSubjectDid) {\n        throw new InvalidRequest(\n          'Credential subject ID and VP Holder mismatch',\n        );\n      }\n    }\n    let publicKey;\n    if (this.vcSignatureVerification) {\n      const didResolution = await this.didResolver.resolve(vc.issuer);\n      if (didResolution.didResolutionMetadata.error) {\n        throw new InvalidRequest(\n          `Did resolution failed. Error ${\n            didResolution.didResolutionMetadata.error\n          }: ${didResolution.didResolutionMetadata.message}`,\n        );\n      }\n      const didDocument = didResolution.didDocument!;\n      const jwk = getAssertionMethodJWKKeys(didDocument, header.kid);\n      publicKey = await importJWK(jwk);\n      try {\n        await jwtVerify(data, publicKey, {clockTolerance: 5});\n      } catch (error: any) {\n        throw new InvalidRequest(\n          `Descriptor \"${descriptorId}\" JWT verification failed`,\n        );\n      }\n    }\n    // Verify VC Schema\n    if (vc.credentialSchema) {\n      // TODO: Analyze if we should force this\n      const schemaArray = Array.isArray(vc.credentialSchema)\n        ? vc.credentialSchema\n        : [vc.credentialSchema];\n      for (const W3CSchema of schemaArray) {\n        const schema = await this.getSchema(W3CSchema);\n        const validateFunction = await ajv.compileAsync(schema);\n        const validationResult = validateFunction(vc);\n        if (!validationResult) {\n          throw new InvalidRequest(\n            'VC does not validate against its own schema specification',\n          );\n        }\n      }\n    }\n    const verificationResult = await this.externalValidation(\n      vc,\n      dataModelVersion,\n      publicKey,\n    );\n    if (verificationResult.isError()) {\n      throw new InvalidRequest(verificationResult.unwrapError().message);\n    }\n    this.jwtCache[data] = {\n      data: payload as JwtVcPayload,\n      alg: header.alg as JWA_ALGS,\n      type: 'vc',\n    };\n    return {\n      data: payload as JwtVcPayload,\n      jwa: header.alg as JWA_ALGS,\n    };\n  }\n\n  private async getSchema(schema: W3CVcSchemaDefinition) {\n    // WE ONLYE SUPPORT JSON SCHEMA FOR NOW\n    // TODO: WE SHOULD CHECK THE TYPE\n    try {\n      const response = await fetch(schema.id);\n      return (await response.json()) as SchemaObject;\n    } catch (e: any) {\n      throw new InvalidRequest(`Can't recover credential schema: ${e}`);\n    }\n  }\n\n  private async decodeAndParse(\n    format: W3CVerifiableCredentialFormats | W3CVerifiablePresentationFormats,\n    data: any,\n    validAlgs: JWA_ALGS[],\n    descriptorId: string,\n  ): Promise<{\n    data: JwtVpPayload | JwtVcPayload;\n    jwa: JWA_ALGS;\n  }> {\n    if (checkIfLdFormat(format)) {\n      throw new InternalNonceError('LD Format are not supported right now');\n    }\n    switch (format) {\n      case 'jwt_vc':\n      case 'jwt_vc_json':\n        return {\n          ...(await this.deserializeJwtVc(data, validAlgs, descriptorId)),\n        };\n      case 'jwt_vp':\n      case 'jwt_vp_json':\n        return {\n          ...(await this.deserializeJwtVp(data, validAlgs, descriptorId)),\n        };\n      case 'jwt_vc_json-ld':\n      case 'ldp_vc':\n      case 'ldp_vp':\n        throw new InternalNonceError('LD formats are not supported right now');\n    }\n  }\n\n  private async deserializeJwtVp(\n    data: any,\n    validAlgs: JWA_ALGS[],\n    descriptorId: string,\n  ): Promise<{\n    data: JwtVpPayload;\n    jwa: JWA_ALGS;\n  }> {\n    // TODO: It could be interesting to check against a json schema or with joi\n    if (typeof data !== 'string') {\n      throw new InvalidRequest('A JWT VP must be in string format');\n    }\n    const cacheData = this.jwtCache[data];\n    if (cacheData && cacheData.type === 'vp') {\n      return {data: cacheData.data as JwtVpPayload, jwa: cacheData.alg};\n    }\n    const {header, payload} = decodeToken(data);\n    if (!header.kid) {\n      // TODO: Define error type\n      throw new InvalidRequest(\n        `Descriptor \"${descriptorId}\" JWT VP must contains a 'kid' parameter`,\n      );\n    }\n    if (!validAlgs.includes(header.alg as JWA_ALGS)) {\n      throw new InvalidRequest(\n        `Descriptor \"${descriptorId}\" JWT VP unssuported JWA: ${header.alg}`,\n      );\n    }\n    const jwtPayload = payload as JwtPayload;\n    if (!jwtPayload.vp) {\n      throw new InvalidRequest(`Descriptor ${descriptorId} is not a JWT VP`);\n    }\n    const vp = (payload as JwtVpPayload).vp as W3CVerifiablePresentation;\n    // TODO: WE SHOULD CHECK THE @CONTEXT. SHOULD IT BE THE SAME AS THE VC?\n    if (!vp.type.includes(W3C_VP_TYPE)) {\n      throw new InvalidRequest(\n        `Descriptor ${descriptorId} JWT VP must be of type \"${W3C_VP_TYPE}\"`,\n      );\n    }\n    if (jwtPayload.aud !== this.audience) {\n      throw new InvalidRequest('Invalid audience for VP Token');\n    }\n    const holderDidUrl = obtainDid(header.kid, vp.holder);\n    const didResolution = await this.didResolver.resolve(holderDidUrl);\n    if (didResolution.didResolutionMetadata.error) {\n      throw new InvalidRequest(\n        `Did resolution failed. Error ${\n          didResolution.didResolutionMetadata.error\n        }: ${didResolution.didResolutionMetadata.message}`,\n      );\n    }\n    const didDocument = didResolution.didDocument!;\n    const holderDid = didDocument.id;\n    const jwk = getAuthentificationJWKKeys(didDocument, header.kid);\n    const publicKey = await importJWK(jwk);\n    // TODO: MOST PROBABLY WE SHOULD CATCH THE POSSIBLE EXCEPTION THAT THIS METHOD MAY THROW\n    await jwtVerify(data, publicKey, {clockTolerance: 5});\n    // TODO: repensar la estructura de esta callback, el jwtNonce no lo usamos porque partimos\n    // de que el nonceResponse viene de ese jwtNonce. Además, tal vez lo que deberíamos pasar\n    // es el token entero para que la validación tuviera más datos?\n    const nonceVerification = await this.nonceAndStateValidation(\n      holderDidUrl,\n      jwtPayload.nonce,\n      jwtPayload.state,\n    );\n    if (nonceVerification.isError()) {\n      throw new InvalidRequest(nonceVerification.unwrapError().message);\n    }\n    this.vpHolder = holderDid;\n    this.jwtCache[data] = {\n      data: payload as JwtVpPayload,\n      alg: header.alg as JWA_ALGS,\n      type: 'vp',\n    };\n    return {\n      data: payload as JwtVpPayload,\n      jwa: header.alg as JWA_ALGS,\n    };\n  }\n\n  private verifyVcDates(\n    vc: W3CVerifiableCredential,\n    dataModel: W3CDataModel,\n    descriptorId: string,\n  ) {\n    const now = Date.now();\n    if (vc.validFrom) {\n      const validFrom = Date.parse(vc.validFrom);\n      if (validFrom > now) {\n        throw new InvalidRequest(`${descriptorId} is not yet valid`);\n      }\n    }\n    switch (dataModel) {\n      case W3CDataModel.V1: {\n        const vcV1 = vc as W3CVerifiableCredentialV1;\n        if (!vcV1.issuanceDate) {\n          throw new InvalidRequest(\n            'A W3C VC for data model V1 Must contain an issuanceDate parameter',\n          );\n        }\n        const issuanceDate = Date.parse(vcV1.issuanceDate);\n        if (now < issuanceDate) {\n          throw new InvalidRequest(`${descriptorId} invalid issuance date`);\n        }\n        if (vcV1.expirationDate) {\n          const expirationDate = Date.parse(vcV1.expirationDate);\n          if (now >= expirationDate) {\n            throw new InvalidRequest(`${descriptorId} is expired`);\n          }\n        }\n        break;\n      }\n      case W3CDataModel.V2: {\n        const vcV2 = vc as W3CVerifiableCredentialV2;\n        if (vcV2.validUntil) {\n          const validUntil = Date.parse(vcV2.validUntil);\n          if (validUntil <= now) {\n            throw new InvalidRequest(`${descriptorId} is expired`);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  private checkVcDataModel(vc: W3CVerifiableCredential): W3CDataModel {\n    if (vc['@context'].includes(CONTEXT_VC_DATA_MODEL_1)) {\n      return W3CDataModel.V1;\n    }\n    if (vc['@context'].includes(CONTEXT_VC_DATA_MODEL_2)) {\n      return W3CDataModel.V2;\n    }\n    throw new InvalidRequest('Invalid @¢ontext specified');\n  }\n\n  private checkFormatValidity(\n    expectedFormats: LdFormat & JwtFormat,\n    currentFormat:\n      | W3CVerifiableCredentialFormats\n      | W3CVerifiablePresentationFormats,\n  ): JWA_ALGS[] {\n    const formatData = expectedFormats[currentFormat];\n    if (!formatData) {\n      throw new InvalidRequest('Unexpected format detected');\n    }\n    if ('proof_type' in formatData) {\n      // TODO: NOT SUPPORTED FOR NOW\n      throw new InternalNonceError('JLD not supported right now');\n    }\n    if ('alg' in formatData) {\n      return formatData.alg;\n    }\n    throw new InvalidRequest('Unrecognized format detected');\n  }\n\n  private async extractCredentialFromVp(\n    data: any, // TODO: Revise in the future\n    descriptor: DescriptorMap,\n    expectedFormats: LdFormat & JwtFormat,\n    endObjectFormats: LdFormat & JwtFormat,\n  ): Promise<JwtVcPayload> {\n    let currentTraversalObject = data;\n    let lastJwa: JWA_ALGS;\n    let lastFormat;\n    const resolveDescriptor = async () => {\n      if (currentDescriptor!.id && currentDescriptor!.id !== mainId) {\n        throw new InvalidRequest(\n          'Each level of nesting of a descriptor map must have the same ID',\n        );\n      }\n      const path = currentDescriptor!.path ?? '$';\n      if (!currentDescriptor!.format) {\n        throw new InvalidRequest(\n          `Descriptor ${currentDescriptor!.id} needs to specify a format`,\n        );\n      }\n      const validAlgs = this.checkFormatValidity(\n        expectedFormats,\n        currentDescriptor!.format,\n      );\n      const tmp = this.resolveJsonPath(currentTraversalObject, path);\n      if (!tmp.length) {\n        throw new InvalidRequest(\n          `Descriptor ${currentDescriptor!.id} json path does not resolve to any data`,\n        );\n      }\n      const parseResult = await this.decodeAndParse(\n        currentDescriptor!.format,\n        tmp[0],\n        validAlgs,\n        descriptor.id,\n      );\n      currentTraversalObject = parseResult.data;\n      lastJwa = parseResult.jwa;\n    };\n    let currentDescriptor: DescriptorMap | undefined = descriptor;\n    const mainId = currentDescriptor.id;\n    if (!currentDescriptor.id) {\n      throw new InvalidRequest('Each input descriptor must have an ID');\n    }\n    do {\n      await resolveDescriptor();\n      lastFormat = currentDescriptor.format;\n      currentDescriptor = currentDescriptor.path_nested;\n    } while (currentDescriptor);\n    if (!currentTraversalObject.vc) {\n      // If Json Linked Data is implemented, the condicional expression should change\n      throw new InvalidRequest(\n        `Submission resolution for descriptor ${descriptor.id} did not resolve in a valid VC`,\n      );\n    }\n    const validAlgs = this.checkFormatValidity(endObjectFormats, lastFormat);\n    if (!validAlgs.includes(lastJwa!)) {\n      throw new InvalidRequest('Unsupported JWA');\n    }\n    return currentTraversalObject as JwtVcPayload;\n  }\n\n  private resolveJsonPath(data: any, path: string) {\n    if (path === '$') {\n      return [data];\n    }\n    return jsonpath.query(data, path, 1);\n  }\n\n  private async resolveInputDescriptor(\n    inputDescriptor: PresentationInputDescriptor,\n    data: JwtVcPayload,\n  ): Promise<Record<string, any>> {\n    const result: Record<string, any> = {};\n    if (inputDescriptor.constraints.fields) {\n      for (const field of inputDescriptor.constraints.fields) {\n        if (!field.path.length) {\n          throw new InvalidRequest(\n            'At least one path must be specified for each field specification',\n          );\n        }\n        let claimFound;\n        let validPath;\n        for (const path of field.path) {\n          const tmp = jsonpath.query(data, path, 1);\n          if (tmp.length) {\n            if (field.filter) {\n              const validateFunction = await ajv.compileAsync(field.filter);\n              const validationResult = validateFunction(tmp[0]);\n              if (validationResult) {\n                claimFound = tmp[0];\n                validPath = path;\n                break;\n              }\n            } else {\n              claimFound = tmp[0];\n              validPath = path;\n              break;\n            }\n          }\n        }\n        if (claimFound === undefined && !field.optional) {\n          throw new InvalidRequest(\n            `Input descriptor ${inputDescriptor.id} not resolved`,\n          );\n        }\n        const entryId = field.id ?? validPath!;\n        result[entryId] = claimFound;\n      }\n    }\n    return result;\n  }\n\n  private findDefinitionInputDescriptor(\n    definition: DIFPresentationDefinition,\n    id: string,\n  ): PresentationInputDescriptor {\n    const result = definition.input_descriptors.find(\n      descriptor => descriptor.id === id,\n    );\n    if (!result) {\n      throw new InvalidRequest(`Invalid descriptor id: \"${id}\"`);\n    }\n    return result;\n  }\n}\n\nfunction checkIfLdFormat(\n  format: W3CVerifiableCredentialFormats | W3CVerifiablePresentationFormats,\n) {\n  return format.includes('ld');\n}\n"]}