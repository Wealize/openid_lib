{"version":3,"file":"vp-resolver.js","sourceRoot":"","sources":["../../../../src/core/presentations/vp-resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import jsonpath from \"jsonpath\";\nimport fetch from 'node-fetch';\nimport { JwtPayload } from \"jsonwebtoken\";\nimport { Resolver } from \"did-resolver\";\nimport { importJWK, jwtVerify } from \"jose\";\nimport { ajv } from \"./validator.js\";\nimport {\n  DIFPresentationDefinition,\n  JwtFormat,\n  LdFormat,\n  PresentationInputDescriptor\n} from \"../../common/interfaces/presentation_definition.interface\";\nimport {\n  DIFPresentationSubmission,\n  DescriptorMap\n} from \"../../common/interfaces/presentation_submission.interface\";\nimport {\n  W3CVerifiablePresentation\n} from \"../../common/interfaces/verifiable_presentation.interface\";\nimport {\n  W3CDataModel,\n  W3CVerifiableCredentialFormats,\n  W3CVerifiablePresentationFormats\n} from \"../../common/formats/index.js\";\nimport {\n  JwtVpPayload,\n  JwtVcPayload,\n  W3CVcSchemaDefinition,\n  W3CVerifiableCredential,\n  W3CVerifiableCredentialV1,\n  W3CVerifiableCredentialV2\n} from \"../../common/interfaces/index.js\";\nimport {\n  CONTEXT_VC_DATA_MODEL_1,\n  CONTEXT_VC_DATA_MODEL_2,\n  JWA_ALGS,\n  W3C_VP_TYPE\n} from \"../../common/constants/index.js\";\nimport {\n  decodeToken,\n  didFromDidUrl,\n  getAssertionMethodJWKKeys,\n  getAuthentificationJWKKeys,\n  obtainDid\n} from \"../../common/utils/index.js\";\nimport {\n  InternalNonceError,\n  InvalidRequest,\n  OpenIdError\n} from \"../../common/classes/error/index.js\";\nimport {\n  CredentialAdditionalVerification,\n  NonceAndStateVerification,\n  VpExtractedData\n} from \"./types\";\nimport { SchemaObject } from \"ajv\";\n\n\n/**\n * Component specialized in the verification of verifiable\n * submissions, for which it requires the original definition\n * and the submission delivered together with the VP.\n */\nexport class VpResolver {\n  private jwtCache: Record<\n    string,\n    {\n      type: \"vp\" | \"vc\",\n      data: JwtVcPayload | JwtVpPayload,\n      alg: JWA_ALGS\n    }>;\n  private vpHolder: string | undefined;\n  /**\n   * Main constructor of this class\n   * @param didResolver The DID Resolver to employ\n   * @param audience The expected audience in the tokens that will be processed\n   * @param externalValidation Callback that will be used to request external\n   * verification of any detected VC. This verification should focus on\n   * validating issues related to the trust framework and the use case.\n   * @param nonceAndStateValidation Callback the nonces specified in any JWT VP\n   * @param vcSignatureVerification Flag indicating whether the signatures of the VCs\n   * included in the VP should be verified. To that regard, the DID Resolver provided must\n   * be able to generate the needed DID Documents\n   */\n  constructor(\n    private didResolver: Resolver,\n    private audience: string,\n    private externalValidation: CredentialAdditionalVerification,\n    private nonceAndStateValidation: NonceAndStateVerification,\n    private vcSignatureVerification: boolean = false\n  ) {\n    this.jwtCache = {};\n  }\n\n  emitError(error: OpenIdError) {\n\n  }\n\n  /**\n   * Verify a Verifiable Presentation\n   * @param vp Any data structure in which the VP is located\n   * @param definition The definition of the presentation to be\n   * used to verify the PV\n   * @param submission The presentation submission submitted with the VP\n   * @returns Data extracted from the credentials contained\n   * in the VP as indicated in the definition provided.\n   */\n  async verifyPresentation(\n    vp: any,\n    definition: DIFPresentationDefinition,\n    submission: DIFPresentationSubmission\n  ): Promise<VpExtractedData> {\n    try {\n      if (definition.id !== submission.definition_id) {\n        throw new InvalidRequest(\n          \"The submission definition ID is incorrect\"\n        );\n      }\n      if (submission.descriptor_map.length !== definition.input_descriptors.length) {\n        throw new InvalidRequest(\n          \"The descriptor map length does not coincide with the input descriptors one\"\n        );\n      }\n      const idsAlreadyUsed = new Set<string>();\n      const descriptorClaimsMap = {} as Record<string, any>;\n      for (const descriptor of submission.descriptor_map) {\n        if (idsAlreadyUsed.has(descriptor.id)) {\n          throw new InvalidRequest(\"Can't be two descriptors with the same ID\");\n        }\n        const inputDescriptor = this.findDefinitionInputDescriptor(definition, descriptor.id);\n        const rootFormats = definition.format;\n        const format = inputDescriptor.format ?? rootFormats;\n        const vc = await this.extractCredentialFromVp(vp, descriptor, rootFormats, format);\n        const claimData = await this.resolveInputDescriptor(inputDescriptor, vc);\n        descriptorClaimsMap[inputDescriptor.id] = claimData;\n        idsAlreadyUsed.add(inputDescriptor.id);\n      }\n      this.jwtCache = {};\n      const result = {\n        claimsData: descriptorClaimsMap,\n        holderDid: this.vpHolder!\n      };\n      this.vpHolder = undefined;\n      return result;\n    } catch (error: any) {\n      this.jwtCache = {};\n      this.vpHolder = undefined;\n      throw error;\n    }\n  }\n\n  private async deserializeJwtVc(\n    data: any,\n    validAlgs: JWA_ALGS[],\n    descriptorId: string,\n  ): Promise<{\n    data: JwtVcPayload,\n    jwa: JWA_ALGS\n  }> {\n    if (typeof data !== \"string\") {\n      throw new InvalidRequest(\"JWT Token must be in string format\");\n    }\n    const cacheData = this.jwtCache[data];\n    if (cacheData && cacheData.type == \"vc\") {\n      return { data: cacheData.data as JwtVcPayload, jwa: cacheData.alg };\n    }\n    const { header, payload } = decodeToken(data);\n    if (!header.kid) {\n      throw new InvalidRequest(\n        `Descriptor \"${descriptorId}\" JWT VC must contains a 'kid' parameter`\n      );\n    }\n    if (!validAlgs.includes(header.alg as JWA_ALGS)) {\n      throw new InvalidRequest(\n        `Descriptor \"${descriptorId}\" JWT VC unssuported JWA: ${header.alg}`\n      );\n    }\n    if (!(\"vc\" in (payload as JwtPayload))) {\n      throw new InvalidRequest(`Descriptor ${descriptorId} is not a JWT VC`);\n    }\n    const vc = (payload as JwtVcPayload).vc as W3CVerifiableCredential;\n    const dataModelVersion = this.checkVcDataModel(vc);\n    this.verifyVcDates(vc, dataModelVersion, descriptorId);\n    if (!vc.credentialSubject.id) {\n      throw new InvalidRequest(`Credential Subject not defined`);\n    }\n    const vcSubject = vc.credentialSubject.id;\n    const vcSubjectDid = didFromDidUrl(vcSubject);\n    if (vcSubjectDid) {\n      if (!this.vpHolder) {\n        throw new InvalidRequest(\n          \"A VC has been detected prior to any VP\"\n        );\n      }\n      if (this.vpHolder !== vcSubjectDid) {\n        throw new InvalidRequest(\n          \"Credential subject ID and VP Holder mismatch\"\n        );\n      }\n    }\n    let publicKey;\n    if (this.vcSignatureVerification) {\n      const didResolution = await this.didResolver.resolve(vc.issuer);\n      if (didResolution.didResolutionMetadata.error) {\n        throw new InvalidRequest(\n          `Did resolution failed. Error ${didResolution.didResolutionMetadata.error\n          }: ${didResolution.didResolutionMetadata.message}`);\n      }\n      const didDocument = didResolution.didDocument!;\n      const jwk = getAssertionMethodJWKKeys(didDocument, header.kid);\n      publicKey = await importJWK(jwk);\n      try {\n        await jwtVerify(data, publicKey, { clockTolerance: 5 });\n      } catch (error: any) {\n        throw new InvalidRequest(\n          `Descriptor \"${descriptorId}\" JWT verification failed`\n        );\n      }\n    }\n    // Verify VC Schema\n    if (vc.credentialSchema) { // TODO: Analyze if we should force this\n      const schemaArray = Array.isArray(vc.credentialSchema) ?\n        vc.credentialSchema :\n        [vc.credentialSchema];\n      for (const W3CSchema of schemaArray) {\n        const schema = await this.getSchema(W3CSchema);\n        const validateFunction = await ajv.compileAsync(schema);\n        const validationResult = validateFunction(vc);\n        if (!validationResult) {\n          throw new InvalidRequest(\n            \"VC does not validate against its own schema specification\"\n          );\n        }\n      }\n    }\n    const verificationResult = await this.externalValidation(\n      vc,\n      dataModelVersion,\n      publicKey\n    );\n    if (verificationResult.isError()) {\n      throw new InvalidRequest(verificationResult.unwrapError().message);\n    }\n    this.jwtCache[data] = {\n      data: payload as JwtVcPayload,\n      alg: header.alg as JWA_ALGS,\n      type: \"vc\"\n    };\n    return {\n      data: payload as JwtVcPayload,\n      jwa: header.alg as JWA_ALGS\n    }\n  }\n\n  private async getSchema(schema: W3CVcSchemaDefinition) {\n    // WE ONLYE SUPPORT JSON SCHEMA FOR NOW\n    // TODO: WE SHOULD CHECK THE TYPE\n    try {\n      const response = await fetch(schema.id);\n      return await response.json() as SchemaObject;\n    } catch (e: any) {\n      throw new InvalidRequest(`Can't recover credential schema: ${e}`);\n    }\n  }\n\n  private async decodeAndParse(\n    format: W3CVerifiableCredentialFormats | W3CVerifiablePresentationFormats,\n    data: any,\n    validAlgs: JWA_ALGS[],\n    descriptorId: string,\n  ): Promise<{\n    data: JwtVpPayload | JwtVcPayload,\n    jwa: JWA_ALGS\n  }> {\n    if (checkIfLdFormat(format)) {\n      throw new InternalNonceError(\"LD Format are not supported right now\");\n    }\n    switch (format) {\n      case \"jwt_vc\":\n      case \"jwt_vc_json\":\n        return { ...await this.deserializeJwtVc(data, validAlgs, descriptorId) };\n      case \"jwt_vp\":\n      case \"jwt_vp_json\":\n        return { ...await this.deserializeJwtVp(data, validAlgs, descriptorId) };\n      case \"jwt_vc_json-ld\":\n      case \"ldp_vc\":\n      case \"ldp_vp\":\n        throw new InternalNonceError(\"LD formats are not supported right now\");\n    }\n  }\n\n  private async deserializeJwtVp(\n    data: any,\n    validAlgs: JWA_ALGS[],\n    descriptorId: string\n  ): Promise<{\n    data: JwtVpPayload,\n    jwa: JWA_ALGS\n  }> {\n    // TODO: It could be interesting to check against a json schema or with joi\n    if (typeof data !== \"string\") {\n      throw new InvalidRequest(\"A JWT VP must be in string format\");\n    }\n    const cacheData = this.jwtCache[data];\n    if (cacheData && cacheData.type == \"vp\") {\n      return { data: cacheData.data as JwtVpPayload, jwa: cacheData.alg };\n    }\n    const { header, payload } = decodeToken(data);\n    if (!header.kid) {\n      // TODO: Define error type\n      throw new InvalidRequest(\n        `Descriptor \"${descriptorId}\" JWT VP must contains a 'kid' parameter`\n      );\n    }\n    if (!validAlgs.includes(header.alg as JWA_ALGS)) {\n      throw new InvalidRequest(\n        `Descriptor \"${descriptorId}\" JWT VP unssuported JWA: ${header.alg}`\n      );\n    }\n    const jwtPayload = payload as JwtPayload;\n    if (!jwtPayload.vp) {\n      throw new InvalidRequest(`Descriptor ${descriptorId} is not a JWT VP`);\n    }\n    const vp = (payload as JwtVpPayload).vp as W3CVerifiablePresentation;\n    // TODO: WE SHOULD CHECK THE @CONTEXT. SHOULD IT BE THE SAME AS THE VC?\n    if (!vp.type.includes(W3C_VP_TYPE)) {\n      throw new InvalidRequest(\n        `Descriptor ${descriptorId} JWT VP must be of type \"${W3C_VP_TYPE}\"`\n      );\n    }\n    if (jwtPayload.aud !== this.audience) {\n      throw new InvalidRequest(\"Invalid audience for VP Token\");\n    }\n    const holderDidUrl = obtainDid(header.kid, vp.holder);\n    const didResolution = await this.didResolver.resolve(holderDidUrl);\n    if (didResolution.didResolutionMetadata.error) {\n      throw new InvalidRequest(\n        `Did resolution failed. Error ${didResolution.didResolutionMetadata.error\n        }: ${didResolution.didResolutionMetadata.message}`);\n    }\n    const didDocument = didResolution.didDocument!;\n    const holderDid = didDocument.id;\n    const jwk = getAuthentificationJWKKeys(didDocument, header.kid);\n    const publicKey = await importJWK(jwk);\n    // TODO: MOST PROBABLY WE SHOULD CATCH THE POSSIBLE EXCEPTION THAT THIS METHOD MAY THROW\n    await jwtVerify(data, publicKey, { clockTolerance: 5 });\n    // TODO: repensar la estructura de esta callback, el jwtNonce no lo usamos porque partimos\n    // de que el nonceResponse viene de ese jwtNonce. Además, tal vez lo que deberíamos pasar\n    // es el token entero para que la validación tuviera más datos?\n    const nonceVerification = await this.nonceAndStateValidation(\n      holderDidUrl,\n      jwtPayload.nonce,\n      jwtPayload.state\n    );\n    if (nonceVerification.isError()) {\n      throw new InvalidRequest(nonceVerification.unwrapError().message);\n    }\n    this.vpHolder = holderDid;\n    this.jwtCache[data] = {\n      data: payload as JwtVpPayload,\n      alg: header.alg as JWA_ALGS,\n      type: \"vp\"\n    };\n    return {\n      data: payload as JwtVpPayload,\n      jwa: header.alg as JWA_ALGS\n    }\n  }\n\n  private verifyVcDates(\n    vc: W3CVerifiableCredential,\n    dataModel: W3CDataModel,\n    descriptorId: string,\n  ) {\n    const now = Date.now();\n    if (vc.validFrom) {\n      const validFrom = Date.parse(vc.validFrom);\n      if (validFrom > now) {\n        throw new InvalidRequest(`${descriptorId} is not yet valid`);\n      }\n    }\n    switch (dataModel) {\n      case W3CDataModel.V1:\n        const vcV1 = vc as W3CVerifiableCredentialV1;\n        if (!vcV1.issuanceDate) {\n          throw new InvalidRequest(\n            \"A W3C VC for data model V1 Must contain an issuanceDate parameter\"\n          );\n        }\n        const issuanceDate = Date.parse(vcV1.issuanceDate);\n        if (now < issuanceDate) {\n          throw new InvalidRequest(`${descriptorId} invalid issuance date`);\n        }\n        if (vcV1.expirationDate) {\n          const expirationDate = Date.parse(vcV1.expirationDate);\n          if (now >= expirationDate) {\n            throw new InvalidRequest(`${descriptorId} is expired`);\n          }\n        }\n        break\n      case W3CDataModel.V2:\n        const vcV2 = vc as W3CVerifiableCredentialV2;\n        if (vcV2.validUntil) {\n          const validUntil = Date.parse(vcV2.validUntil);\n          if (validUntil <= now) {\n            throw new InvalidRequest(`${descriptorId} is expired`);\n          }\n        }\n        break\n    }\n  }\n\n  private checkVcDataModel(\n    vc: W3CVerifiableCredential\n  ): W3CDataModel {\n    if (CONTEXT_VC_DATA_MODEL_1.every((x) => vc[\"@context\"].includes(x))) {\n      return W3CDataModel.V1;\n    }\n    if (CONTEXT_VC_DATA_MODEL_2.every((x) => vc[\"@context\"].includes(x))) {\n      return W3CDataModel.V2;\n    }\n    throw new InvalidRequest(\"Invalid @¢ontext specified\")\n  }\n\n  private checkFormatValidity(\n    expectedFormats: LdFormat & JwtFormat,\n    currentFormat: W3CVerifiableCredentialFormats | W3CVerifiablePresentationFormats\n  ): JWA_ALGS[] {\n    const formatData = expectedFormats[currentFormat];\n    if (!formatData) {\n      throw new InvalidRequest(\"Unexpected format detected\");\n    }\n    if ((\"proof_type\") in formatData) {\n      // TODO: NOT SUPPORTED FOR NOW\n      throw new InternalNonceError(\"JLD not supported right now\");\n    }\n    if ((\"alg\") in formatData) {\n      return formatData.alg;\n    }\n    throw new InvalidRequest(\"Unrecognized format detected\");\n  }\n\n  private async extractCredentialFromVp(\n    data: any, // TODO: Revise in the future\n    descriptor: DescriptorMap,\n    expectedFormats: LdFormat & JwtFormat,\n    endObjectFormats: LdFormat & JwtFormat\n  ): Promise<JwtVcPayload> {\n    let currentTraversalObject = data;\n    let lastJwa: JWA_ALGS;\n    let lastFormat;\n    const resolveDescriptor = async () => {\n      if (currentDescriptor!.id && currentDescriptor!.id !== mainId) {\n        throw new InvalidRequest(\n          \"Each level of nesting of a descriptor map must have the same ID\"\n        );\n      }\n      const path = currentDescriptor!.path ?? \"$\";\n      if (!currentDescriptor!.format) {\n        throw new InvalidRequest(\n          `Descriptor ${currentDescriptor!.id} needs to specify a format`\n        );\n      }\n      const validAlgs = this.checkFormatValidity(expectedFormats, currentDescriptor!.format);\n      const tmp = this.resolveJsonPath(currentTraversalObject, path);\n      if (!tmp.length) {\n        throw new InvalidRequest(\n          `Descriptor ${currentDescriptor!.id} json path does not resolve to any data`\n        );\n      }\n      const parseResult = await this.decodeAndParse(\n        currentDescriptor!.format,\n        tmp[0],\n        validAlgs,\n        descriptor.id\n      );\n      currentTraversalObject = parseResult.data;\n      lastJwa = parseResult.jwa;\n    }\n    let currentDescriptor: DescriptorMap | undefined = descriptor;\n    const mainId = currentDescriptor.id;\n    if (!currentDescriptor.id) {\n      throw new InvalidRequest(\"Each input descriptor must have an ID\");\n    }\n    do {\n      await resolveDescriptor();\n      lastFormat = currentDescriptor.format;\n      currentDescriptor = currentDescriptor.path_nested;\n    } while (currentDescriptor);\n    if (!currentTraversalObject.vc) {\n      // If Json Linked Data is implemented, the condicional expression should change\n      throw new InvalidRequest(\n        `Submission resolution for descriptor ${descriptor.id} did not resolve in a valid VC`\n      );\n    }\n    const validAlgs = this.checkFormatValidity(endObjectFormats, lastFormat);\n    if (!validAlgs.includes(lastJwa!)) {\n      throw new InvalidRequest(`Unsupported JWA`);\n    }\n    return currentTraversalObject as JwtVcPayload;\n  }\n\n  private resolveJsonPath(data: any, path: string) {\n    if (path === \"$\") {\n      return [data];\n    }\n    return jsonpath.query(data, path, 1);\n  }\n\n  private async resolveInputDescriptor(\n    inputDescriptor: PresentationInputDescriptor,\n    data: JwtVcPayload\n  ): Promise<Record<string, any>> {\n    const result: Record<string, any> = {};\n    if (inputDescriptor.constraints.fields) {\n      for (const field of inputDescriptor.constraints.fields) {\n        if (!field.path.length) {\n          throw new InvalidRequest(\n            \"At least one path must be specified for each field specification\"\n          );\n        }\n        let claimFound;\n        let validPath;\n        for (const path of field.path) {\n          const tmp = jsonpath.query(data, path, 1);\n          if (tmp.length) {\n            if (field.filter) {\n              const validateFunction = await ajv.compileAsync(field.filter);\n              const validationResult = validateFunction(tmp[0]);\n              if (validationResult) {\n                claimFound = tmp[0];\n                validPath = path;\n                break;\n              }\n            } else {\n              claimFound = tmp[0];\n              validPath = path;\n              break;\n            }\n          }\n        }\n        if (claimFound === undefined && !field.optional) {\n          throw new InvalidRequest(`Input descriptor ${inputDescriptor.id} not resolved`);\n        }\n        const entryId = field.id ?? validPath!;\n        result[entryId] = claimFound;\n      }\n    }\n    return result;\n  }\n\n  private findDefinitionInputDescriptor(\n    definition: DIFPresentationDefinition,\n    id: string\n  ): PresentationInputDescriptor {\n    const result = definition.input_descriptors.find((descriptor) => descriptor.id === id);\n    if (!result) {\n      throw new InvalidRequest(`Invalid descriptor id: \"${id}\"`);\n    }\n    return result;\n  }\n}\n\nfunction checkIfLdFormat(\n  format: W3CVerifiableCredentialFormats | W3CVerifiablePresentationFormats\n) {\n  return format.includes(\"ld\");\n}\n"]}