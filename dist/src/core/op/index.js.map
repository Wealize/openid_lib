{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/core/op/index.ts"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,EAAE,EAAE,IAAI,MAAM,EAAE,MAAM,MAAM,CAAC;AACpC,OAAO,WAAW,MAAM,aAAa,CAAC;AACtC,OAAO,EACL,mBAAmB,EACpB,MAAM,sDAAsD,CAAC;AAI9D,OAAO,EAEL,oBAAoB,EACrB,MAAM,oDAAoD,CAAC;AAM5D,OAAO,EAAE,iBAAiB,EAAE,MAAM,kCAAkC,CAAC;AACrE,OAAO,EACL,mBAAmB,EACnB,oBAAoB,EACrB,MAAM,uBAAuB,CAAC;AAyB/B;;;GAGG;AACH,MAAM,OAAO,cAAc;IACzB;;;;;;;OAOG;IACH,YACU,WAAmB;IAC3B,wDAAwD;IAChD,eAAkC,EAClC,QAA0C,EAC1C,QAAgB;QAJhB,gBAAW,GAAX,WAAW,CAAQ;QAEnB,oBAAe,GAAf,eAAe,CAAmB;QAClC,aAAQ,GAAR,QAAQ,CAAkC;QAC1C,aAAQ,GAAR,QAAQ,CAAQ;IAG1B,CAAC;IAED,6EAA6E;IAC7E;;;;;;;;;;;OAWG;IACG,sBAAsB,CAC1B,GAAW,EACX,eAAqC,EACrC,aAAgC,EAAE,uCAAuC;IACzE,YAAkC,EAClC,KAAa,EACb,QAAgB,EAChB,aAGC;;YAED,IAAI,cAAc,EAAE,qBAAqB,EAAE,aAAa,CAAC;YACzD,IAAI,aAAa,EAAE,CAAC;gBAClB,cAAc,GAAG,aAAa,CAAC,cAAc,CAAC;gBAC9C,qBAAqB,GAAG,aAAa,CAAC,qBAAqB,CAAC;YAC9D,CAAC;iBAAM,CAAC;gBACN,aAAa,GAAG,oBAAoB,CAAC,mBAAmB,CAAC,CAAC;gBAC1D,cAAc,GAAG,MAAM,iBAAiB,CAAC,aAAa,CAAC,CAAC;gBACxD,qBAAqB,GAAG,MAAM,CAAC,CAAC,wBAAwB;YAC1D,CAAC;YACD,MAAM,SAAS,GAAG,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACpC,MAAM,KAAK,GAAG,MAAM,EAAE,CAAC;YACvB,MAAM,gBAAgB,GAAG,IAAI,mBAAmB,CAC9C,aAAa,EACb,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,WAAW,CACjB;iBACE,SAAS,CAAC,KAAK,CAAC;iBAChB,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC;iBAC3B,eAAe,CAAC,YAAY,CAAC;iBAC7B,iBAAiB,CAAC,cAAc,EAAE,qBAAqB,CAAC;iBACxD,SAAS,CAAC,KAAK,CAAC;iBAChB,KAAK,EAAE,CAAC;YACX,IAAI,QAAQ,CAAC;YACb,IAAI,MAA8B,CAAC;YACnC,QAAQ,eAAe,EAAE,CAAC;gBACxB,KAAK,oBAAoB,CAAC,UAAU;oBAClC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;oBACvE,QAAQ,GAAG,GAAG,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,WAAW,CAAC,SAAS,CAChE,gCAAK,gBAAgB,KAAE,OAAO,GAAsB,CAAC,EAAE,CAAC;oBAC1D,MAAM,GAAG,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,CAAC;oBAChD,MAAM;gBACR,KAAK,oBAAoB,CAAC,aAAa;oBACrC,QAAQ,GAAG,GAAG,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,WAAW,CAAC,SAAS,CAAC,gBAAoC,CAAC,EAAE,CAAC;oBAC3G,MAAM,GAAG,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;oBAClC,MAAM;YACV,CAAC;YACD,IAAI,aAAa,EAAE,CAAC;gBAClB,MAAM,CAAC,aAAa,GAAG,aAAa,CAAC;YACvC,CAAC;YACD,OAAO,MAAM,CAAC;QAChB,CAAC;KAAA;IAED,oBAAoB;IAEpB,CAAC;IAED,qBAAqB;IAErB,CAAC;IAED,oBAAoB;IAEpB,CAAC;IAED,qBAAqB;IAErB,CAAC;IAED,mBAAmB;IAEnB,CAAC;CAEF","sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport querystring from \"querystring\";\nimport {\n  AuthzRequestBuilder\n} from \"../../common/builders/authz/authz_request.builder.js\";\nimport {\n  AuthorizationDetails\n} from \"../../common/interfaces/authz_details.interface.js\";\nimport {\n  AuthzRequest,\n  AuthzRequestLocation\n} from \"../../common/interfaces/authz_request.interface.js\";\nimport {\n  HolderMetadata,\n  ServiceMetadata\n} from \"../../common/interfaces/client_metadata.interface.js\";\nimport { AuthzResponseType } from \"../../common/types/index.js\";\nimport { generateChallenge } from \"../../common/utils/pkce.utils.js\";\nimport {\n  DEFAULT_PKCE_LENGTH,\n  generateRandomString\n} from '../../common/index.js';\n\n/**\n * Extended authorisation request\n */\ninterface AuthzRequestMethodData {\n  /**\n   * The petition in JWT format.\n   */\n  jwt?: string,\n  /**\n   * The URL to send the request to\n   */\n  url: string,\n  /**\n   * The state associated with the request\n   */\n  state: string,\n  /**\n   * The \"code_verifier\" that resolves the challenge included \n   * in the request\n   */\n  code_verifier?: string\n}\n\n/**\n * Define an entity acting as OpenIDProvider. As such, it can generate \n * authorisation requests\n */\nexport class OpenIDProvider {\n  /**\n   * Constructor of the OpenIDProvider class\n   * @param redirectUri URI at which responses to authorisation requests\n   *  are expected to be received\n   * @param requestCallback Callback that allow to sign the request objects\n   * @param metadata The authorisation metadata of the OP\n   * @param clientId The identifier of the OP\n   */\n  constructor(\n    private redirectUri: string,\n    // For now, support for JWT. TODO: EXPAND SUPPORT TO JLD\n    private requestCallback: AuthzSignCallback,\n    private metadata: ServiceMetadata | HolderMetadata,\n    private clientId: string,\n  ) {\n\n  }\n\n  // TODO: DERIVE FROM CREDENTIAL OFFER FOR ISSUER STATE AND EVEN AUTHZ DETAILS\n  /**\n   * Allows to generate an autorisation request\n   * @param url The URL to send the request to\n   * @param requestLocation Allows to indicate where the request parameters \n   * should be included.\n   * @param response_type The response type expected\n   * @param authzDetails The autorisation details to include in the request\n   * @param scope The scope to include in the request\n   * @param audience The \"aud\" parameter to include in the request if a JWT is generated.\n   * @param pkceChallenge The challenge to include in the request.\n   * @returns The authorisation request to sent in URL format with additional information.\n   */\n  async createBaseAuthzRequest(\n    url: string,\n    requestLocation: AuthzRequestLocation,\n    response_type: AuthzResponseType, // Most probably could be set to \"code\"\n    authzDetails: AuthorizationDetails,\n    scope: string,\n    audience: string,\n    pkceChallenge?: {\n      code_challenge: string,\n      code_challenge_method: string\n    }\n  ): Promise<AuthzRequestMethodData> {\n    let code_challenge, code_challenge_method, code_verifier;\n    if (pkceChallenge) {\n      code_challenge = pkceChallenge.code_challenge;\n      code_challenge_method = pkceChallenge.code_challenge_method;\n    } else {\n      code_verifier = generateRandomString(DEFAULT_PKCE_LENGTH);\n      code_challenge = await generateChallenge(code_verifier);\n      code_challenge_method = \"S256\"; // TODO: Define new type\n    }\n    const hasParams = url.includes(\"?\");\n    const state = uuidv4();\n    const authzBaseRequest = new AuthzRequestBuilder(\n      response_type,\n      this.clientId,\n      this.redirectUri\n    )\n      .withScope(scope)\n      .withMetadata(this.metadata)\n      .addAuthzDetails(authzDetails)\n      .withCodeChallenge(code_challenge, code_challenge_method)\n      .withState(state)\n      .build();\n    let location;\n    let result: AuthzRequestMethodData;\n    switch (requestLocation) {\n      case AuthzRequestLocation.JWT_OBJECT:\n        const request = await this.requestCallback(authzBaseRequest, audience);\n        location = `${url}${hasParams ? \"&\" : \"/?\"}${querystring.stringify(\n          { ...authzBaseRequest, request } as Record<any, any>)}`;\n        result = { url: location, state, jwt: request };\n        break;\n      case AuthzRequestLocation.PLAIN_REQUEST:\n        location = `${url}${hasParams ? \"&\" : \"/?\"}${querystring.stringify(authzBaseRequest as Record<any, any>)}`;\n        result = { url: location, state };\n        break;\n    }\n    if (code_verifier) {\n      result.code_verifier = code_verifier;\n    }\n    return result;\n  }\n\n  createIdTokenReponse() {\n\n  }\n\n  createVpTokenResponse() {\n\n  }\n\n  verifyIdTokenRequest() {\n\n  }\n\n  verifyVpTokenResponse() {\n\n  }\n\n  verifyAuthzResponse() {\n\n  }\n\n}\n\n/**\n * Function type that allows to sign an AuthzRequest\n * @param data The request to sign\n * @param target The audience of the request\n * @returns The signed request in string format\n */\nexport type AuthzSignCallback = (data: AuthzRequest, target: string) => Promise<string>;\n"]}