{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/core/op/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {v4 as uuidv4} from 'uuid';\nimport querystring from 'querystring';\nimport {AuthzRequestBuilder} from '../../common/builders/authz/authz_request.builder.js';\nimport {AuthorizationDetails} from '../../common/interfaces/authz_details.interface.js';\nimport {\n  AuthzRequest,\n  AuthzRequestLocation,\n} from '../../common/interfaces/authz_request.interface.js';\nimport {\n  HolderMetadata,\n  ServiceMetadata,\n} from '../../common/interfaces/client_metadata.interface.js';\nimport {AuthzResponseType} from '../../common/types/index.js';\nimport {generateChallenge} from '../../common/utils/pkce.utils.js';\nimport {DEFAULT_PKCE_LENGTH, generateRandomString} from '../../common/index.js';\n\n/**\n * Extended authorisation request\n */\ninterface AuthzRequestMethodData {\n  /**\n   * The petition in JWT format.\n   */\n  jwt?: string;\n  /**\n   * The URL to send the request to\n   */\n  url: string;\n  /**\n   * The state associated with the request\n   */\n  state: string;\n  /**\n   * The \"code_verifier\" that resolves the challenge included\n   * in the request\n   */\n  code_verifier?: string;\n}\n\n/**\n * Define an entity acting as OpenIDProvider. As such, it can generate\n * authorisation requests\n */\nexport class OpenIDProvider {\n  /**\n   * Constructor of the OpenIDProvider class\n   * @param redirectUri URI at which responses to authorisation requests\n   *  are expected to be received\n   * @param requestCallback Callback that allow to sign the request objects\n   * @param metadata The authorisation metadata of the OP\n   * @param clientId The identifier of the OP\n   */\n  constructor(\n    private redirectUri: string,\n    // For now, support for JWT. TODO: EXPAND SUPPORT TO JLD\n    private requestCallback: AuthzSignCallback,\n    private metadata: ServiceMetadata | HolderMetadata,\n    private clientId: string,\n  ) {}\n\n  // TODO: DERIVE FROM CREDENTIAL OFFER FOR ISSUER STATE AND EVEN AUTHZ DETAILS\n  /**\n   * Allows to generate an autorisation request\n   * @param url The URL to send the request to\n   * @param requestLocation Allows to indicate where the request parameters\n   * should be included.\n   * @param response_type The response type expected\n   * @param authzDetails The autorisation details to include in the request\n   * @param scope The scope to include in the request\n   * @param audience The \"aud\" parameter to include in the request if a JWT is generated.\n   * @param pkceChallenge The challenge to include in the request.\n   * @returns The authorisation request to sent in URL format with additional information.\n   */\n  async createBaseAuthzRequest(\n    url: string,\n    requestLocation: AuthzRequestLocation,\n    response_type: AuthzResponseType, // Most probably could be set to \"code\"\n    authzDetails: AuthorizationDetails,\n    scope: string,\n    audience: string,\n    pkceChallenge?: {\n      code_challenge: string;\n      code_challenge_method: string;\n    },\n  ): Promise<AuthzRequestMethodData> {\n    let code_challenge, code_challenge_method, code_verifier;\n    if (pkceChallenge) {\n      code_challenge = pkceChallenge.code_challenge;\n      code_challenge_method = pkceChallenge.code_challenge_method;\n    } else {\n      code_verifier = generateRandomString(DEFAULT_PKCE_LENGTH);\n      code_challenge = await generateChallenge(code_verifier);\n      code_challenge_method = 'S256'; // TODO: Define new type\n    }\n    const hasParams = url.includes('?');\n    const state = uuidv4();\n    const authzBaseRequest = new AuthzRequestBuilder(\n      response_type,\n      this.clientId,\n      this.redirectUri,\n    )\n      .withScope(scope)\n      .withMetadata(this.metadata)\n      .addAuthzDetails(authzDetails)\n      .withCodeChallenge(code_challenge, code_challenge_method)\n      .withState(state)\n      .build();\n    let location;\n    let result: AuthzRequestMethodData;\n    switch (requestLocation) {\n      case AuthzRequestLocation.JWT_OBJECT: {\n        const request = await this.requestCallback(authzBaseRequest, audience);\n        location = `${url}${hasParams ? '&' : '/?'}${querystring.stringify({\n          ...authzBaseRequest,\n          request,\n        } as Record<any, any>)}`;\n        result = {url: location, state, jwt: request};\n        break;\n      }\n      case AuthzRequestLocation.PLAIN_REQUEST:\n        location = `${url}${hasParams ? '&' : '/?'}${querystring.stringify(authzBaseRequest as Record<any, any>)}`;\n        result = {url: location, state};\n        break;\n    }\n    if (code_verifier) {\n      result.code_verifier = code_verifier;\n    }\n    return result;\n  }\n\n  createIdTokenReponse() {}\n\n  createVpTokenResponse() {}\n\n  verifyIdTokenRequest() {}\n\n  verifyVpTokenResponse() {}\n\n  verifyAuthzResponse() {}\n}\n\n/**\n * Function type that allows to sign an AuthzRequest\n * @param data The request to sign\n * @param target The audience of the request\n * @returns The signed request in string format\n */\nexport type AuthzSignCallback = (\n  data: AuthzRequest,\n  target: string,\n) => Promise<string>;\n"]}