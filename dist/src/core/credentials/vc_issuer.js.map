{"version":3,"file":"vc_issuer.js","sourceRoot":"","sources":["../../../../src/core/credentials/vc_issuer.ts"],"names":[],"mappings":"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","sourcesContent":["import {v4 as uuidv4} from 'uuid';\nimport {P, match} from 'ts-pattern';\nimport moment from 'moment';\nimport {Resolver} from 'did-resolver';\nimport {JWK} from 'jose';\nimport {Jwt, JwtPayload} from 'jsonwebtoken';\nimport {ControlProof} from '../../common/classes/control_proof.js';\nimport {\n  CONTEXT_VC_DATA_MODEL_1,\n  CONTEXT_VC_DATA_MODEL_2,\n  C_NONCE_EXPIRATION_TIME,\n} from '../../common/constants/index.js';\nimport {\n  W3CDataModel,\n  W3CVerifiableCredentialFormats,\n} from '../../common/formats/index.js';\nimport {CredentialRequest} from '../../common/interfaces/credential_request.interface.js';\nimport {IssuerMetadata} from '../../common/interfaces/issuer_metadata.interface.js';\nimport {\n  W3CVcSchemaDefinition,\n  W3CVerifiableCredential,\n  W3CVerifiableCredentialV1,\n  W3CVerifiableCredentialV2,\n} from '../../common/interfaces/w3c_verifiable_credential.interface.js';\nimport {\n  decodeToken,\n  verifyJwtWithExpAndAudience,\n} from '../../common/utils/jwt.utils.js';\nimport {VcFormatter} from './formatters.js';\nimport {CredentialResponse} from '../../common/interfaces/credential_response.interface.js';\nimport * as VcIssuerTypes from './types.js';\nimport {\n  InternalNonceError,\n  InvalidCredentialRequest,\n  InvalidDataProvided,\n  InvalidProof,\n  InvalidToken,\n} from '../../common/classes/index.js';\nimport {areDidUrlsSameDid} from '../../common/utils/did.utils.js';\nimport {CredentialDataManager} from './credential_data_manager.js';\nimport {arraysAreEqual} from '../../common/utils/array.utils.js';\nimport {StateManager} from '../state/index.js';\nimport {NonceManager} from '../nonce/index.js';\n\n/**\n * W3C credentials issuer in both deferred and In-Time flows\n */\nexport class W3CVcIssuer {\n  /**\n   * Constructor of the issuer\n   * @param metadata Issuer metadata\n   * @param didResolver Object that allows to resolve the DIDs found\n   * @param issuerDid The DID of the issuer\n   * @param signCallback Callback used to sign the VC generated\n   * @param cNonceRetrieval Callback to recover the challenge nonce expected\n   * for a control proof\n   * @param getVcSchema Callback to recover the schema associated with a VC\n   * @param getCredentialData Callback to recover the subject data to\n   * include in the VC\n   * It can also be used to specify if the user should follow the deferred flow\n   */\n  private nonceManager;\n  constructor(\n    private metadata: IssuerMetadata,\n    private didResolver: Resolver,\n    private issuerDid: string,\n    private signCallback: VcIssuerTypes.VcSignCallback,\n    stateManager: StateManager,\n    private credentialDataManager: CredentialDataManager,\n    private vcTypesContextRelationship?: Record<string, string>,\n  ) {\n    this.nonceManager = new NonceManager(stateManager);\n  }\n\n  /**\n   * Allows to verify a JWT Access Token in string format\n   * @param token The access token\n   * @param publicKeyJwkAuthServer The public key that should verify the token\n   * @param tokenVerifyCallback A callback that can be used to perform an\n   * additional verification of the contents of the token\n   * @returns Access token in JWT format\n   * @throws If data provided is incorrect\n   */\n  async verifyAccessToken(\n    token: string,\n    publicKeyJwkAuthServer: JWK,\n    tokenVerifyCallback?: VcIssuerTypes.AccessTokenVerifyCallback,\n  ): Promise<Jwt> {\n    await verifyJwtWithExpAndAudience(\n      token,\n      publicKeyJwkAuthServer,\n      this.metadata.credential_issuer,\n    );\n    const jwt = decodeToken(token);\n    if (tokenVerifyCallback) {\n      const verificationResult = await tokenVerifyCallback(\n        jwt.header,\n        jwt.payload as JwtPayload,\n      );\n      if (!verificationResult.valid) {\n        throw new InvalidToken(\n          `Invalid access token provided${verificationResult.error ? ': ' + verificationResult.error : '.'}`,\n        );\n      }\n    }\n    return jwt;\n  }\n\n  /**\n   * Allows to generate a Credential Response in accordance to\n   * the OID4VCI specification\n   * @param acessToken The access token needed to perform the operation\n   * @param credentialRequest The credential request sent by an user\n   * @param dataModel The W3 VC Data Model version\n   * @returns A credential response with a VC or a deferred code\n   * @throws If data provided is incorrect\n   */\n  async generateCredentialResponse(\n    acessToken: Jwt,\n    credentialRequest: CredentialRequest,\n    dataModel: W3CDataModel,\n  ): Promise<CredentialResponse> {\n    this.checkCredentialTypesAndFormat(\n      credentialRequest.types,\n      credentialRequest.format,\n    );\n    const controlProof = ControlProof.fromJSON(credentialRequest.proof);\n    const proofAssociatedClient = controlProof.getAssociatedIdentifier();\n    const jwtPayload = acessToken.payload as JwtPayload;\n    const innerNonce = jwtPayload.nonce as string;\n    const cNonceResult = await this.nonceManager.getChallengeNonce(innerNonce);\n    if (cNonceResult.isError()) {\n      throw new InvalidProof('Invalid provided nonce for control proof');\n    }\n    const cNonce = cNonceResult.unwrap();\n    if (cNonce.timestamp + cNonce.expirationTime <= Date.now()) {\n      await this.nonceManager.deleteNonce(innerNonce);\n      throw new InvalidCredentialRequest('Challenge nonce has expired');\n    }\n    match(cNonce)\n      .with({operationType: {type: 'Verification'}}, _ => {\n        throw new InvalidCredentialRequest('Invalid provided nonce');\n      })\n      .with(\n        {\n          operationType: {\n            type: 'Issuance',\n            vcTypes: {type: 'Know', vcTypes: P.select()},\n          },\n        },\n        types => {\n          if (!areDidUrlsSameDid(proofAssociatedClient, jwtPayload.sub!)) {\n            throw new InvalidToken(\n              'Access Token was issued for a different identifier that the one that sign the proof',\n            );\n          }\n          if (!arraysAreEqual(types as string[], credentialRequest.types)) {\n            throw new InvalidCredentialRequest(\n              'The provided token does not allow for the issuance of a VC of the specified types',\n            );\n          }\n        },\n      )\n      .with(\n        {operationType: {type: 'Issuance', vcTypes: {type: 'Uknown'}}},\n        _ => {\n          // Most probably generated from pre-auth flow\n        },\n      )\n      .otherwise(() => {\n        throw new InternalNonceError(\n          'Unexpected behaviour detected at nonce matching',\n        );\n      });\n    await controlProof.verifyProof(\n      innerNonce,\n      this.metadata.credential_issuer,\n      this.didResolver,\n    );\n    const credentialSubject =\n      await this.credentialDataManager.resolveCredentialSubject(\n        jwtPayload.sub!,\n        proofAssociatedClient,\n      );\n    const credentialResponse = await this.credentialResponseMatch(\n      credentialRequest.types,\n      credentialSubject,\n      credentialRequest.format,\n      dataModel,\n    );\n    await this.nonceManager.deleteNonce(innerNonce);\n    return credentialResponse;\n  }\n\n  private async credentialResponseMatch(\n    types: string[],\n    credentialSubject: string,\n    format: W3CVerifiableCredentialFormats,\n    dataModel: W3CDataModel,\n  ) {\n    const credentialDataOrDeferred =\n      await this.credentialDataManager.getCredentialData(\n        types,\n        credentialSubject,\n      );\n    return match(credentialDataOrDeferred)\n      .with({type: 'InTime'}, async data =>\n        this.generateW3CCredential(\n          types,\n          data.schema,\n          credentialSubject,\n          data,\n          format,\n          dataModel,\n        ),\n      )\n      .with({type: 'Deferred'}, data => {\n        return {\n          acceptance_token: data.deferredCode,\n        };\n      })\n      .exhaustive();\n  }\n\n  /**\n   * Allows for the generation of a VC without an Access Token\n   * @param did The DID if the holder of the VC\n   * @param dataModel The W3 VC Data Model version\n   * @param types The types of the VCs\n   * @param format The format of the VC\n   * @returns A credential response with the VC\n   */\n  async generateVcDirectMode(\n    did: string,\n    dataModel: W3CDataModel,\n    types: string[],\n    format: W3CVerifiableCredentialFormats,\n  ): Promise<CredentialResponse> {\n    this.checkCredentialTypesAndFormat(types, format);\n    return await this.credentialResponseMatch(types, did, format, dataModel);\n  }\n\n  // TODO: valorar quitar iss de 'CredentialDataOrDeferred' y homogeneizar comportamiento entre V1 y V2\n  // El motivo es que V1 incluye un campo issuanceDate, y además EBSI está obligando a que sea igual al 'iat' del token.\n  // Sin embargo, en V2 ese campo no existe. La propusta sería:\n  // - En V2, validFrom se asocia con nbf, y iat sería Date.now(). Según esto, en formatDataModel2, iat debería ajustarse a\n  //   Date.now() y valorar quitar el nbf o también asignarlo a Date.now(). Notar diferencia entre info de la credencial y del token\n  // - En V1, validFrom se asocia con nbf, issued y issuanceDate y iat con Date.now()\n  private generateCredentialTimeStamps(data: VcIssuerTypes.CredentialMetadata) {\n    if (data.validUntil && data.expiresInSeconds) {\n      throw new InvalidDataProvided(\n        '\"expiresInSeconds\" and \"validUntil\" can\\'t be defined at the same time',\n      );\n    }\n\n    const issuanceDate = (() => {\n      const iss = data.iss ? moment(data.iss, true) : moment();\n      if (!iss.isValid()) {\n        throw new InvalidDataProvided(\n          'Invalid specified date for \"iss\" parameter',\n        );\n      }\n      return iss;\n    })();\n\n    const validFrom = (() => {\n      const nbf = data.nbf ? moment(data.nbf, true) : issuanceDate.clone();\n      if (!nbf.isValid()) {\n        throw new InvalidDataProvided(\n          'Invalid specified date for \"nbf\" parameter',\n        );\n      }\n      if (nbf.isBefore(issuanceDate)) {\n        throw new InvalidDataProvided(\n          '\"validFrom\" can not be before \"issuanceDate\"',\n        );\n      }\n      return nbf;\n    })();\n\n    const expirationDate = (() => {\n      const exp = (() => {\n        if (data.validUntil) {\n          return moment(data.validUntil, true);\n        } else if (data.expiresInSeconds) {\n          return issuanceDate.clone().add(data.expiresInSeconds, 'seconds');\n        } else {\n          return undefined;\n        }\n      })();\n      if (exp) {\n        if (!exp.isValid()) {\n          throw new InvalidDataProvided(\n            'Invalid specified date for \"expirationDate\" parameter',\n          );\n        }\n        if (exp.isBefore(validFrom)) {\n          throw new InvalidDataProvided(\n            '\"expirationDate\" can not be before \"validFrom\"',\n          );\n        }\n      }\n      return exp;\n    })();\n\n    return {\n      issuanceDate: issuanceDate.utc().toISOString(),\n      validFrom: validFrom.utc().toISOString(),\n      expirationDate: expirationDate\n        ? expirationDate.utc().toISOString()\n        : undefined,\n    };\n  }\n\n  private generateVcId() {\n    return `urn:uuid:${uuidv4()}`;\n  }\n\n  private generateW3CDataForV1(\n    type: string[],\n    schema: W3CVcSchemaDefinition | W3CVcSchemaDefinition[],\n    subject: string,\n    vcData: VcIssuerTypes.InTimeCredentialData,\n  ): W3CVerifiableCredentialV1 {\n    const timestamps = this.generateCredentialTimeStamps(vcData.metadata);\n    const vcId = this.generateVcId();\n    return {\n      '@context': [CONTEXT_VC_DATA_MODEL_1],\n      type,\n      credentialSchema: schema,\n      issuanceDate: timestamps.issuanceDate,\n      validFrom: timestamps.validFrom,\n      expirationDate: timestamps.expirationDate,\n      id: vcId,\n      credentialStatus: vcData.status,\n      issuer: this.issuerDid,\n      issued: timestamps.issuanceDate,\n      termsOfUse: vcData.termfOfUse,\n      credentialSubject: {\n        id: subject,\n        ...vcData.data,\n      },\n    };\n  }\n\n  private generateW3CDataForV2(\n    type: string[],\n    schema: W3CVcSchemaDefinition | W3CVcSchemaDefinition[],\n    subject: string,\n    vcData: VcIssuerTypes.InTimeCredentialData,\n  ): W3CVerifiableCredentialV2 {\n    const vcId = this.generateVcId();\n    const timestamps = this.generateCredentialTimeStamps(vcData.metadata);\n    return {\n      '@context': [CONTEXT_VC_DATA_MODEL_2],\n      type,\n      credentialSchema: schema,\n      validFrom: timestamps.validFrom,\n      validUntil: timestamps.expirationDate,\n      id: vcId,\n      credentialStatus: vcData.status,\n      termsOfUse: vcData.termfOfUse,\n      issuer: this.issuerDid,\n      credentialSubject: {\n        id: subject,\n        ...vcData.data,\n      },\n    };\n  }\n\n  private extendsVcContext(content: W3CVerifiableCredential) {\n    if (!this.vcTypesContextRelationship) {\n      return;\n    }\n    const typesToExtend = Object.keys(this.vcTypesContextRelationship);\n    for (const type of content.type) {\n      if (typesToExtend.includes(type)) {\n        content['@context'].push(this.vcTypesContextRelationship[type]);\n      }\n    }\n  }\n\n  private async generateW3CCredential(\n    type: string[],\n    schema: W3CVcSchemaDefinition | W3CVcSchemaDefinition[],\n    subject: string,\n    vcData: VcIssuerTypes.InTimeCredentialData,\n    format: W3CVerifiableCredentialFormats,\n    dataModel: W3CDataModel,\n  ): Promise<CredentialResponse> {\n    const formatter = VcFormatter.fromVcFormat(format, dataModel);\n    const content: W3CVerifiableCredential =\n      dataModel === W3CDataModel.V1\n        ? this.generateW3CDataForV1(type, schema, subject, vcData)\n        : this.generateW3CDataForV2(type, schema, subject, vcData);\n    this.extendsVcContext(content);\n    const vcPreSign = formatter.formatVc(content);\n    const signedVc = await this.signCallback(format, vcPreSign);\n    // Generate a new nonce\n    const nonce = uuidv4();\n    const expirationTime = C_NONCE_EXPIRATION_TIME; // TODO: Make it configurable\n    await this.nonceManager.saveNonce(nonce, {\n      timestamp: Date.now(),\n      sub: subject,\n      operationType: {\n        type: 'Issuance',\n        vcTypes: {\n          type: 'Know',\n          vcTypes: type,\n        },\n      },\n      type: 'ChallengeNonce',\n      expirationTime,\n    });\n    return {\n      format: format,\n      credential: signedVc,\n      c_nonce: nonce,\n      c_nonce_expires_in: expirationTime, // TODO: This could be interesting to be configurable\n    };\n  }\n\n  /**\n   * Allows to exchange a deferred code for a VC\n   * @param acceptanceToken The deferred code sent by the issuer in a\n   * previous instance\n   * @param dataModel The W3C VC Data Model version\n   * @returns A credential response with the VC generated or a new\n   * (or the same) deferred code\n   */\n  async exchangeAcceptanceTokenForVc(\n    acceptanceToken: string,\n    dataModel: W3CDataModel,\n  ): Promise<CredentialResponse> {\n    const exchangeResult =\n      await this.credentialDataManager.deferredExchange(acceptanceToken);\n    if (exchangeResult.isError()) {\n      throw new InvalidToken(\n        `Invalid acceptance token: ${exchangeResult.unwrapError().message}`,\n      );\n    }\n    const credentialDataResponse = exchangeResult.unwrap();\n    return await match(credentialDataResponse)\n      .with({type: 'InTime'}, async dataResponse =>\n        this.generateW3CCredential(\n          dataResponse.types,\n          dataResponse.schema,\n          dataResponse.data.id!,\n          dataResponse,\n          dataResponse.format,\n          dataModel,\n        ),\n      )\n      .with({type: 'Deferred'}, data => {\n        return {\n          acceptance_token: data.deferredCode,\n        };\n      })\n      .exhaustive();\n  }\n\n  private checkCredentialTypesAndFormat(\n    types: string[],\n    format: W3CVerifiableCredentialFormats,\n  ) {\n    const typesSet = new Set(types);\n    for (const credentialSupported of this.metadata.credentials_supported) {\n      const supportedSet = new Set(credentialSupported.types);\n      if (\n        [...typesSet].every(item => supportedSet.has(item)) &&\n        credentialSupported.format === format\n      ) {\n        return;\n      }\n    }\n    throw new InvalidCredentialRequest(\n      'Unsuported combination of credential types and format',\n    );\n  }\n}\n"]}