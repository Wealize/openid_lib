{"version":3,"file":"jwt.utils.js","sourceRoot":"","sources":["../../../../src/common/utils/jwt.utils.ts"],"names":[],"mappings":"AAAA,OAAO,EAAM,SAAS,EAAE,SAAS,EAAC,MAAM,MAAM,CAAC;AAC/C,OAAO,KAAK,GAAG,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,YAAY,EAAC,MAAM,qBAAqB,CAAC;AAEjD;;;;;GAKG;AACH,MAAM,UAAU,WAAW,CAAC,YAAoB;IAC9C,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,YAAY,EAAE,EAAC,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;IAC1D,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,MAAM,IAAI,YAAY,CAAC,0BAA0B,CAAC,CAAC;IACrD,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,2BAA2B,CAC/C,KAAa,EACb,YAAiB,EACjB,QAAiB;IAEjB,MAAM,SAAS,GAAG,MAAM,SAAS,CAAC,YAAY,CAAC,CAAC;IAChD,MAAM,OAAO,GAAG,MAAM,SAAS,CAAC,KAAK,EAAE,SAAS,EAAE,EAAC,cAAc,EAAE,CAAC,EAAC,CAAC,CAAC;IACvE,IACE,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG;QACpB,OAAO,CAAC,OAAO,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,EACnD,CAAC;QACD,MAAM,IAAI,YAAY,CAAC,+CAA+C,CAAC,CAAC;IAC1E,CAAC;IACD,IAAI,QAAQ,EAAE,CAAC;QACb,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,KAAK,QAAQ,EAAE,CAAC;YAC7D,MAAM,IAAI,YAAY,CAAC,2CAA2C,CAAC,CAAC;QACtE,CAAC;IACH,CAAC;AACH,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,SAAS,CAAC,GAAW,EAAE,GAAY;IACjD,IAAI,GAAG,IAAI,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;QACjC,OAAO,GAAG,CAAC;IACb,CAAC;IACD,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;QAC3B,MAAM,IAAI,YAAY,CAAC,yCAAyC,CAAC,CAAC;IACpE,CAAC;IACD,OAAO,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC","sourcesContent":["import {JWK, importJWK, jwtVerify} from 'jose';\nimport * as jwt from 'jsonwebtoken';\nimport {InvalidToken} from '../classes/index.js';\n\n/**\n * Deserialize a JWT, which allows to obtain its header, payload and signature\n * @param jsonWebtoken The token to deserialize/decode\n * @returns The header, payload and signature of the token provided\n * @throws if the token provided is invalid for decoding\n */\nexport function decodeToken(jsonWebtoken: string): jwt.Jwt {\n  const result = jwt.decode(jsonWebtoken, {complete: true});\n  if (!result) {\n    throw new InvalidToken('Invalid JWT for decoding');\n  }\n  return result;\n}\n\n/**\n * Verify the signature of a JWT and its \"exp\" and \"aud\" attributes\n * @param token The token to verify\n * @param publicKeyJWK The public key that should verify the token\n * @param audience The expected audience of the token\n * @throws if the signature verification failed, the token is expired\n * or the audience is not the expected\n */\nexport async function verifyJwtWithExpAndAudience(\n  token: string,\n  publicKeyJWK: JWK,\n  audience?: string,\n) {\n  const publicKey = await importJWK(publicKeyJWK);\n  const payload = await jwtVerify(token, publicKey, {clockTolerance: 5});\n  if (\n    !payload.payload.exp ||\n    payload.payload.exp < Math.floor(Date.now() / 1000)\n  ) {\n    throw new InvalidToken('JWT is expired or does not have exp parameter');\n  }\n  if (audience) {\n    if (!payload.payload.aud || payload.payload.aud !== audience) {\n      throw new InvalidToken('JWT audience is invalid or is not defined');\n    }\n  }\n}\n\n/**\n * Obtain the DID associated with a token from the \"iss\" or \"kid\" attribute\n * @param kid The \"kid\" attribute of the header of the token\n * @param iss The \"iss\" attribute of the payload of the token\n * @returns The DID of the issuer of the token\n * @throws If it's not possible to extract a DID from the kid attribute and\n * \"iss\" is not present or is not a DID\n */\nexport function obtainDid(kid: string, iss?: string): string {\n  if (iss && iss.startsWith('did')) {\n    return iss;\n  }\n  if (!kid.startsWith('did')) {\n    throw new InvalidToken('Can\\'t extract did from \"kid\" parameter');\n  }\n  return kid.trim().split('#')[0];\n}\n"]}